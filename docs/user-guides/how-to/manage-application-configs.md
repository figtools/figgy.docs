## Manage your Application Configs

A growing theme in the DevOps space is the concept of GitOps. GitOps enables engineers define the _desired state_ of their
services and let some other tool / framework / whatever synchronize the _defined state_ with the _actual state_. Figgy 
is capable of managing similar functionality for your application's configurations. With Figgy you can 
define the configuration state your application needs to successfully run and let Figgy figure out how to reconcile
the difference between your defined state and your remote state. 

This definition is done through a file we'll refer to as the `figgy.json` file. This JSON file defines your 
desired state. Figgy parses this file and prompts you for required input, if any, to synchronize your 
desire and actual remote state. 

Your `figgy.json` can be autogenerated directly from your source code through reflection, static
code analysis, or by tailoring your source to integrate with Figgy conventions. By using one of our supported libraries your
code will automatically generate the `figgy.json` file. From there it can be checked into source control effectively linking
that specific commit to the exact configurations your application needs to run.

## Figgy Integrated Libraries by Language:

- [Python](https://github.com/figtools/figgy.python.lib)
- More to come, please consider contributing!

Language isn't supported yet? No worries! This is a nice-to-have and will save you time but is NOT required to use Figgy. 
You can also write your own without too much trouble. See our [Python](https://github.com/figtools/figgy.python.lib) library
for reference.

By keeping a versioned `figgy.json` in your repository, you'll get these great features:

- Easily break CICD builds before the deploy step by detecting missing configurations.
- Conveniently add and delete groups of configurations by synchronizing your `figgy.json` file.
- Application dependency mapping is clear, making it easy to answer "What does this application talk to?"
- Combat config sprawl. Never have unneeded secrets or configs floating out in the ether again. 

With the right library the overhead should be minimal, in fact, using this feature should save your engineers time. You 
can even integrate the generation or validation of the `figgy.json` file into your git pre-commit hooks!


## What's this `figgy.json` you speak of?

The `figgy.json` file (which can be named `whatever-you-want.json`) declaratively defines the configurations your application
needs to run. The FiggyCLI will parse this file to support lots of great functionality like:

!!! hint  
    
    For a reference on all supported `figgy.json` options, see: [Declarative Configuration](/advanced/delcarative-configuration/)


### [Sync](/commands/config/sync/)

The `sync` command synchronizes your locally declared configuration state (in your figgy.json file) with the current remote
state with the targeted environment. For instance, suppose you run:

```console
    figgy config sync --config figgy.json --env dev
```

Figgy will look-up your currently defined state and compare it to the configuration state in your `dev` environment. Next, Figgy
will prompt you to add any Parameter Store configurations that are missing. Sync will also tell you if there are 
stray configurations in Parameter Store that your code doesn't appear to need anymore. Finally, sync will set up 
[config replication](/getting-started/basics/#the-solution-config-replication) for any global parameters 
your service needs and ensures sure they'll always be available to your service in its namespace.

If your sync succeeds and displays no errors you can feel confident your application will run 
without configuration issues in the targeted environment.

### [Prune](/commands/config/prune/)

Sync will notify you of stray configurations in Parameter Store but [prune](/commands/config/prune/) 
will will walk you through them one-by-one and ask you if you'd like to delete them.

```console
    figgy config cleanup --config figgy.json --env dev
```

Combat unneeded config sprawl with Sync + Prune!

### [Validate](/commands/config/validate/)

The validate command can be easily integrated into your CICD build process to break your build before deployment if your
defined configuration state is not in sync with the current remote configuration state. Validate will exit with a 
non 0 exit code if any configurations are missing application needs to run.

> Bonus: Integrate `validate` into your git pre-commit hook!  --> [Example HEre](https://github.com/figtools/figgy.python-reference/blob/master/pre-commit.hook)

```console
    figgy config validate --config figgy.json --env dev
```
<br/>

### See it in action!

Follow our [Getting Started Demo](/getting-started/demo/) to do **all of these things** in under 15 minutes!

