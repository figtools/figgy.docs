---
title: Manage Application Configs
has_children: false
nav_order: 1
parent: How To
---

## Manage your Application Configs

A growing theme in the DevOps space is the concept of GitOps. GitOps enables engineers define the _desired state_ of their
services and let some other tool / framework / whatever synchronize the _defined state_ with the _actual state_. Figgy 
is capable of accomplishing the same thing but for your application's configurations instead. With Figgy you can 
define the configuration state your application needs to successfully run and let Figgy figure out how to reconcile
the difference between your defined state and your remote state. 

This definition is done through a file we'll refer to as the `figgy.json` file. This JSON file defines your 
desired state. Figgy then parses this file and prompts you for whatever input is needed, if any, to synchronize your 
desire and actual remote state. 

The best part is that your `figgy.json` can be autogenerated directly from your source code through reflection, static
code analysis, or by tailoring your source to integrate with Figgy conventions. Running your
code can automatically generate this `figgy.json` file. From there it can be checked into source control effectively linking
that specific commit to the exact configurations your application needs to run.

In fact, we've already got libraries out there to do this exact thing!

#### Integrated Figgy Libraries by Language:
- [Python](https://github.com/mancej/figgy.python.lib)
- More to come, please consider contributing!

These libraries will dynamically generate your `figgy.json` file. This is a nice-to-have and will save you time, 
but is NOT required to use Figgy. 

By keeping a versioned `figgy.json` in your repsitority, you'll get these great features:

- Easily break CICD builds before the deploy step by detecting missing configurations
- Promote sets of configurations to higher environments (no more tedious copy-pasta).
- Application dependency mapping is clear, making it easy to answer "What does this application talk to?"

With the right library the overhead should be minimal, in fact, using this feature should save your engineers time. You 
can even integrate the generation or validation of the `figgy.json` file into your git pre-commit hooks!


## What's this `figgy.json` you speak of?

The `figgy.json` file (which can be named `whatever-you-want.json`) declaratively defines the configurations your application
needs to run. The some FiggyCLI commands parse this file and to support lots of great functionality like:

For a reference on all supported `figgy.json` options, see: [Declarative Configuration](/docs/advanced/delcarative-configuration.html)


### [Sync](/docs/commands/config/sync.html)

The `sync` command synchronizes your locally declared configuration state (in your figgy.json file) with the current remote
state with the targeted environment. For instance, suppose you run:

```console
    $   figgy config sync --config figgy.json --env dev
```

Figgy will look-up your currently defined state and compare it to the configuration state in your `dev` environment. Next, Figgy
will prompt you to add any Parameter Store configurations that are missing. Sync will also tell you if there are 
orphaned configurations in Parameter Store that your code doesn't appear to need anymore. Finally, sync will set up 
[config replication](/docs/getting-started/basics.html#the-solution-config-replication) for any global parameters 
your service needs and ensures sure they'll always be available to your service in its namespace.

If your sync succeeds and displays no errors you can feel confident your application will run 
without configuration issues in the targeted environment.

### [Cleanup](/docs/commands/config/cleanup.html)

Sync will notify you of orphaned configurations in Parameter Store but [cleanup](/docs/commands/config/cleanup.html) 
will will walk you through them one-by-one and ask you if you'd like to delete them.

```console
    $   figgy config cleanup --config figgy.json --env dev
```

Combat unneeded config sprawl with Sync + Cleanup!

### [Validate](/docs/commands/config/validate.html)

The validate command can be easily integrated into your CICD build process to break your build before deployment if your
defined configuration state is not in sync with the current remote configuration state. Validate will exit with a 
non 0 exit code if any configurations are missing that your application needs to run.

```console
    $   figgy config validate --config figgy.json --env dev
```
<br/>

### See in action!

Follow our [Getting Started Demo](/docs/getting-started/index.html) to do **all of these things** in under 15 minutes!

